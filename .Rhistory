plot(sort(pvals)[1:400], xlab="Genes forted by p-value", ylab="p-values")
abline(0, 0.05/m, lty=2, col=2) # BH
abline(h = 0.05/m, lty=3, col=3) # Bonferroni
abline(h = 1-(1-0.5)^(1/m), lty=4, col=4) # Sidek
var.test(golub[1, ] ~ gol.fac)
gol.fac = factor(golub.cl, levels = 0:1, labels = c("ALL", "AML"))
table(gol.fac)
library(genetics)
library(coin)
path <- "http://www.biostat.umn.edu/~cavanr/FMS_data.txt"
fms <- read.delim(path, header = TRUE, sep = "\t")
trait <- as.numeric(fms$pre.BMI > 25)
pvals <- numeric(225)
for (i in 1:225) {
mysnp <- ordered(fms[, i + 1])
pvals[i] <- pvalue(independence_test(trait ~ mysnp)) }
# No p-value adjustment.
table(pvals < 0.05)
# Bonferroni.
table(pvals < 0.05 / 225)
# Sidek.
table(pvals < 1 - (1 - 0.05)^(1 / 225))
# Benjamini-Hochberg.
table(sort(pvals, na.last = TRUE) * 225 / (1:225) < 0.05)
table(sort(pvals) * 225 / (1:225) < 0.05)
knitr::opts_chunk$set(echo = TRUE)
library(genetics)
path = "http://www.biostat.umn.edu/~cavanr/FMS_data.txt"
fms = read.delim(path, header = TRUE, sep = "\t")
attach(fms)
lm.fit = lm(NDRM.CH ~ actn3_r577x + Gender)
summary(lm.fit)
fms
NDRM.CH
-23.472 + c(-1, 1) * qt(0.975, df = 599) * 2.565
confint(lm.fit)
lm.fit2 = lm(NDRM.CH ~ actn3_r577x + Gender + actn3_r577x:Gender)
anova(lm.fit, lm.fit2)
plot(fitted(lm.fit2), residuals(lm.fit2))
abline(h=0, lty=2)
qqnorm(residuals(lm.fit2))
qqline(residuals(lm.fit2))
library(multtest)
data(golub)
library(multtest)
data(golub)
knitr::opts_chunk$set(echo = TRUE)
gol.fac = factor(golub.cl, levels=0:1, labels=c("ALL", "AML"))
n1 = summary(gol.fac)[1] # ALL
n2 = summary(gol.fac)[2] # AML
n = n1 + n2
m = 10      # number of genes to test
X = golub[1:m, ] # original data
# Center the two samples
muALL = rowmeans(X[, gol.fac=="ALL"])
gol.fac = factor(golub.cl, levels=0:1, labels=c("ALL", "AML"))
n1 = summary(gol.fac)[1] # ALL
n2 = summary(gol.fac)[2] # AML
n = n1 + n2
m = 10      # number of genes to test
X = golub[1:m, ] # original data
# Center the two samples
muALL = rowMeans(X[, gol.fac=="ALL"])
muAML = rowMeans(X[, gol.fac=="AML"])
Y <- X
Y[, gol.fac=="ALL"] <- Y[, gol.fac=="ALL"] - matrix(muALL, m, n1, byrow=FALSE)
Y[, gol.fac=="AML"] <- Y[, gol.fac=="AML"] - matrix(muAML, m, n2, byrow=FALSE)
B = 250    # number of bootstrap samples
F.mat = matrix(nrow=B, ncol=m) # initialise matrix of bootstrapped statistics
for (b in 1:B) {
indices = sample(1:n, n, replace=TRUE) # indices for the bootstrapped samples
f.test.fun = function(x) {
var.test(x ~gol.fac, conf.level=0.95)$statistic
}
F.mat[b, ] = apply(Y[indices], 1, f.test.fun)
}
gol.fac = factor(golub.cl, levels=0:1, labels=c("ALL", "AML"))
n1 = summary(gol.fac)[1] # ALL
n2 = summary(gol.fac)[2] # AML
n = n1 + n2
m = 10      # number of genes to test
X = golub[1:m, ] # original data
# Center the two samples
muALL = rowMeans(X[, gol.fac=="ALL"])
muAML = rowMeans(X[, gol.fac=="AML"])
Y <- X
Y[, gol.fac=="ALL"] <- Y[, gol.fac=="ALL"] - matrix(muALL, m, n1, byrow=FALSE)
Y[, gol.fac=="AML"] <- Y[, gol.fac=="AML"] - matrix(muAML, m, n2, byrow=FALSE)
B = 250    # number of bootstrap samples
F.mat = matrix(nrow=B, ncol=m) # initialise matrix of bootstrapped statistics
for (b in 1:B) {
indices = sample(1:n, n, replace = TRUE)
f.test.fun = function(x) {
var.test(x ~ gol.fac, conf.level = 0.95)$statistic
}
F.mat[b, ] = apply(Y[, indices], 1, f.test.fun)
}
F.mat
D = data.frame(F.mat)[,1:5]
colnames(D) = golub.gnames[1:5,3]
plot(log(D))
library(MASS)
f.hat = kde2d(log(F.mat[, 4]), log(F.mat[, 5]))
persp(f.hat, theta = 40, phi = 25, shade = 0.5, ticktype = "detailed",
xlab = golub.gnames[1, 3],
ylab = golub.gnames[2, 3],
zlab = "density estimate")
contour(f.hat, xlab = golub.gnames[1,3], ylab = golub.gnames[2,3])
c = 0.5 # initial value
alpha = 0.025 # target FWER
alpha.c = 1 # initial value for the estimated FWER
while (alpha.c > alpha) {
c =c+0.001
rs = rowSums(F.mat > c) # for each sample, count how many reject H0 alpha.c = mean(rs >= 1)
}
c
c = 0.5 # initial value
alpha = 0.025 # target FWER
alpha.c = 1 # initial value for the estimated FWER
while (alpha.c > alpha) {
c =c+0.001
rs = rowSums(F.mat > c) # for each sample, count how many reject H0
alpha.c = mean(rs >= 1)
}
c # the determined critical value
c=1
alpha = 0.025
alpha.c = 1
while (alpha.c > alpha) {
c =c-0.001
ls = rowSums(F.mat < c) # for each sample, count how many reject H0
alpha.c = mean(ls >= 1)
}
c # the determined critical value
?confint
confint(lm.fit2)
library(genetics)
path = "http://www.biostat.umn.edu/~cavanr/FMS_data.txt"
fms = read.delim(path, header = TRUE, sep = "\t")
attach(fms)
lm.fit = lm(NDRM.CH ~ actn3_r577x + Gender)
summary(lm.fit)
-23.472 + c(-1, 1) * qt(0.975, df = 599) * 2.565
confint(lm.fit)
plot(fitted(lm.fit2), residuals(lm.fit2))
gol.fac = factor(golub.cl, levels=0:1, labels=c("ALL", "AML"))
n1 = summary(gol.fac)[1] # ALL
n2 = summary(gol.fac)[2] # AML
n = n1 + n2
m = 10      # number of genes to test
X = golub[1:m, ] # original data
# Center the two samples
muALL = rowMeans(X[, gol.fac=="ALL"])
muAML = rowMeans(X[, gol.fac=="AML"])
Y <- X
Y[, gol.fac=="ALL"] <- Y[, gol.fac=="ALL"] - matrix(muALL, m, n1, byrow=FALSE)
Y[, gol.fac=="AML"] <- Y[, gol.fac=="AML"] - matrix(muAML, m, n2, byrow=FALSE)
B = 250    # number of bootstrap samples
F.mat = matrix(nrow=B, ncol=m) # initialise matrix of bootstrapped statistics
for (b in 1:B) {
indices = sample(1:n, n, replace = TRUE)
f.test.fun = function(x) {
var.test(x ~ gol.fac, conf.level = 0.95)$statistic
}
F.mat[b, ] = apply(Y[, indices], 1, f.test.fun)
}
D = data.frame(F.mat)[,1:5]
colnames(D) = golub.gnames[1:5,3]
plot(log(D))
library(MASS)
f.hat = kde2d(log(F.mat[, 4]), log(F.mat[, 5]))
persp(f.hat, theta = 40, phi = 25, shade = 0.5, ticktype = "detailed",
xlab = golub.gnames[1, 3],
ylab = golub.gnames[2, 3],
zlab = "density estimate")
contour(f.hat, xlab = golub.gnames[1,3], ylab = golub.gnames[2,3])
c = 0.5 # initial value
alpha = 0.025 # target FWER
alpha.c = 1 # initial value for the estimated FWER
while (alpha.c > alpha) {
c =c+0.001
rs = rowSums(F.mat > c) # for each sample, count how many reject H0
alpha.c = mean(rs >= 1)
}
c # the determined critical value
c=1
alpha = 0.025
alpha.c = 1
while (alpha.c > alpha) {
c =c-0.001
ls = rowSums(F.mat < c) # for each sample, count how many reject H0
alpha.c = mean(ls >= 1)
}
c # the determined critical value
confint(lm.fit2)
confint(lm.fit)
lm.fit2 = lm(NDRM.CH ~ actn3_r577x + Gender + actn3_r577x:Gender)
anova(lm.fit, lm.fit2)
lm.fit2 = lm(NDRM.CH ~ actn3_r577x + Gender + actn3_r577x:Gender)
anova(lm.fit, lm.fit2)
plot(fitted(lm.fit2), residuals(lm.fit2))
abline(h=0, lty=2)
qqnorm(residuals(lm.fit2))
qqline(residuals(lm.fit2))
confint(lm.fit2)
confint(lm.fit)
genoDosage <- as.numeric(actn3_r577x) - 1
lm.fit  = lm(NDRM.CH ~ genoDosage + Gender)
lm.fit2 = lm(NDRM.CH ~ genoDosage + Gender + genoDosage:Gender)
summary(lm.fit)
confint(lm.fit)
plot(fitted(lm.fit2), residuals(lm.fit2))
abline(h = 0, lty = 2)
qqnorm(residuals(lm.fit2))
qqline(residuals(lm.fit2))
Fstat <- apply(X, 1, f.test.fun) sort(Fstat)
Fstat <- apply(X, 1, f.test.fun)
sort(Fstat)
knitr::opts_chunk$set(echo = TRUE)
genotypes1 <- read.table("./data/genotypes1.csv", sep=",")
genotypes1
# Study 1
genotypes1 <- read.table("./data/genotypes1.csv", sep=",")
phenotypes1 <- read.table("./data/phenotypes1.csv", sep=",")
# Study 1
genotypes1 <- read.table("./data/genotypes1.csv", sep=",")
phenotypes1 <- read.table("./data/phenotype1.csv", sep=",")
# Study 2
genotypes2 <- read.table("./data/genotypes2.csv", sep=",")
phenotypes2 <- read.table("./data/phenotype2.csv", sep=",")
# Study 3
genotypes3 <- read.table("./data/genotypes3.csv", sep=",")
class(snp10001)
length(snp10001)
library(SNPassoc)
data(SNPs)
dim(SNPs)
colnames(SNPs)
snp10001 <- SNPs$snp10001
is.numeric(snp10001)
levels(snp10001)
class(snp10001)
length(snp10001)
freq <- table(snp10001)
plot(freq)
## 2 - Functions & Loops
# contigency table construction
X <- table(SNPs$casco, SNPs$snp10001)
X
# H0 = 2 variables independent
# H1 = 2 variables dependent
myChisq <- function(Z) {
n <- sum(Z)       # sample size
out <- 0          # initialize the output
for (r in 1:2) {  # loop across rows and cols
for (c in 1:3) {
o <- Z[r, c]                        # observed
e <- sum(Z[r, ]) * sum(Z[, c]) / n  # expected
out <- out + (o - e)^2 / e          # collect the values
}
}
return(out) }
myChisq(X)
qchisq(0.95, df = 2)
chisq.test(X)
## 3 - Exploratory data analysis on microarrays
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.10")
1:n1
?sample
qt(0.95)
qt(0.95, df=99)
qt(0.05, df=99)
qt(0.05, df=200)
qt(0.05, df=10)
knitr::opts_chunk$set(echo = TRUE)
library(genetics)
library(coin)
install.packages("coin")
knitr::opts_chunk$set(echo = TRUE)
library(multtest)
data(golub)
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
y = factor(golub.cl, levels = c(0, 1), labels = c("ALL", "AML"))
x = golub[1, ] # pick the first gene
fit1 = glm(y ~ x, family = "binomial")
summary(fit1)
f = function(x) {
exp(0.7894 + 1.5203 * x) / (1 + exp(0.7894 + 1.5203 * x))
}
curve(f, -5, 5, ylab = expression(p(x)), xlab = "x")
est = coef(summary(fit1))
est
est[2, 4] # p-value for the second coefficient (i.e beta1)
f(0.7)
predict(fit1, newdata = data.frame(x = 0.7), type = "response")
predict(fit1, newdata = data.frame(x = 0.7), type = "response")
newdata1 = data.frame(x = c(-0.3, 1.2, 0.7))
newdata1
predict(fit1, newdata = newdata1, type = "response")
f(newdata1$x)
newdata1 = data.frame(x = c(-0.3, 1.2, 0.7))
predict(fit1, newdata = newdata1, type = "response")
f(newdata1$x)
newdata1 = data.frame(x = c(-0.3, 1.2, 0.7))
predict(fit1, newdata = newdata1, type = "response")
f(newdata1$x)
pvals = 1:3051
for (i in 1:3051) {
fit.i = glm(y ~ golub[i, ], family = "binomial")
pvals[i] = coef(summary(fit.i))[2, 4]
}
pvals[1:10]
testVec = 1:10
testVec
# The following sorts the p-values and returns an index with the
# positions in the original vector pvals. Then pick the first 200.
pos = sort(pvals, decreasing = FALSE, index.return = TRUE)$ix
pos = pos[1:200]
pos[1:10]
install.packages("glmnet")
library(glmnet)
X = t(golub[pos, ]) # t() transposes the input matrix
lasso.fit = glmnet(X, y, family = "binomial", alpha = 1)
plot(lasso.fit, xvar = "lambda")
names(lasso.fit) # names of data objects within the lasso fit
nvar = apply(lasso.fit$beta != 0 , 2, sum) # count the non-zero coefficients
nvar
names(lasso.fit) # names of data objects within the lasso fit
nvar = apply(lasso.fit$beta != 0 , 2, sum) # count the non-zero coefficients
nvar
lasso.var = (1:200)[lasso.fit$beta[, 7] != 0] # indicator for the relevant variables
lasso.var
cv1 = cv.glmnet(X, y, family = "binomial", alpha = 1)
cv1 = cv.glmnet(X, y, family = "binomial", alpha = 1)
cv1$lambda.min
names(cv1)
cv1$lambda
cv1
lasso.fit2 = glmnet(X, y, family = "binomial", alpha = 1, lambda = cv1$lambda.min)
lasso.fit2 = glmnet(X, y, family = "binomial", alpha = 1, lambda = cv1$lambda.min)
lasso.fit2
z1 = golub[lasso.var[1], ]
z2 = golub[lasso.var[2], ]
z3 = golub[lasso.var[3], ]
glm.lasso  = glm(y ~ z1 + z2 + z3, family = "binomial")
glm.lasso2 = glm(y ~ z1, family = "binomial")
anova(glm.lasso2, glm.lasso, test = "Chisq")
shiny::runApp('Work/Shiny_Apps/indexChecker')
tableConstructor <- function() {
rows = c("A", "B", "C", "D", "E", "F", "G", "H")
plate = data.frame(matrix(ncol=12, nrow=8), row.names=rows)
colnames(plate) <- seq(1, 12)
plate[is.na(plate)] = FALSE
return(plate)
}
df <- tableConstructor()
df
df["A", 2] = TRUE
df
df["A", 3] = TRUE
df["A", 4] = TRUE
df["D", 4] = TRUE
df["D", 5] = TRUE
df["D", 6] = TRUE
df
duplicated(df)
which(df, arr.ind = TRUE, useNames = TRUE)
?which
which(df["A",], arr.ind = TRUE, useNames = TRUE)
which(df==TRUE, arr.ind = TRUE, useNames = TRUE)
selected <- which(df==TRUE, arr.ind = TRUE, useNames = TRUE)
selected
class(selected)
names(selected)
selected$A
levels(selected)
rownames(selected)
selected2 <- which(df==TRUE, arr.ind = FALSE, useNames = TRUE)
selected2
selected2 <- which(df==TRUE, arr.ind = TRUE, useNames = FALSE)
selected2
nrows(selected)
nrow(selected)
runApp('Work/Shiny_Apps/indexChecker')
getwd()
read.table("/data/DNA HT Dual Index Kit – 96N Set A Forward")
read.table("./data/DNA HT Dual Index Kit – 96N Set A Forward")
read.table("data/DNA HT Dual Index Kit – 96N Set A Forward")
read.table("data/DNA HT Dual Index Kit – 96N Set A Forward.csv")
read.table("data/DNA HT Dual Index Kit – 96N Set A Forward.csv")
runApp('Work/Shiny_Apps/indexChecker')
setwd("~/Work/Shiny_Apps/indexChecker")
read.table("data/DNA HT Dual Index Kit – 96N Set A Forward.csv")
indexTable <- read.table("data/DNA HT Dual Index Kit – 96N Set A Forward.csv", sep=",",
header=TRUE, col.names=1:12, row.names=1, stringsAsFactors=FALSE)
indexTable
indexTable <- read.table("data/DNA HT Dual Index Kit – 96N Set A Forward.csv", sep=",",
col.names=1:12, row.names=1, stringsAsFactors=FALSE)
indexTable
indexTable <- read.table("data/DNA HT Dual Index Kit – 96N Set A Forward.csv", sep=",",
header=TRUE, row.names=1, stringsAsFactors=FALSE)
indexTable
colnames(indexTable) <- 1:12
indexTable
indexTable <- read.table("data/DNA HT Dual Index Kit – 96N Set A Forward.csv", sep=",",
header=TRUE, row.names=1, stringsAsFactors=FALSE, fill=TRUE)
indexTable
indexTable <- read.table("data/DNA HT Dual Index Kit – 96N Set A Forward.csv", sep=",",
header=TRUE, row.names=1, stringsAsFactors=FALSE, check.names=FALSE)
indexTable
indexTable["A", 12]
runApp()
c(1,2,3) + c(4,5,6)
a = c(1,2,3)
b = c(4,5,6)
c(a, b)
selectIndexToCheck <- function(booleanDF, sequenceDF) {
selectionMatrix <- which(booleanDF==TRUE, arr.ind=TRUE, useNames=TRUE)
sequences <- c()
numSamples <- nrow(selectionMatrix)
for (sample in 1:numSamples) {
sequence <- sequenceDF[selectionMatrix[sample, 'row'], selectionMatrix[sample,'col']]
sequences <- c(sequences, sequence)
}
return(sequences)
}
selectIndexToCheck(df, indexTable)
runApp()
dualIndexTable <- function(kit, direction) {
fileLocation <- paste("data/DNA HT Dual Index Kit – ", kit, " ", direction, ".csv", sep="")
indexTable <- read.table(fileLocation, sep=",",header=TRUE, row.names=1,
stringsAsFactors=FALSE, check.names=FALSE)
return(indexTable)
}
dualIndexTable("Set 96N A", "Forward")
setwd("~/Work/Shiny_Apps/indexChecker")
dualIndexTable("Set 96N A", "Forward")
dualIndexTable <- function(kit, direction) {
fileLocation <- paste("./data/DNA HT Dual Index Kit – ", kit, " ", direction, ".csv", sep="")
indexTable <- read.table(fileLocation, sep=",",header=TRUE, row.names=1,
stringsAsFactors=FALSE, check.names=FALSE)
return(indexTable)
}
dualIndexTable("Set 96N A", "Forward")
dualIndexTable("96N Set A", "Forward")
machineDirection <- function(machine) {
direction <- case_when(
machine == "NextSeq" ~ "Reverse",
machine == "MiSeq" ~ "Forward",
machine == "HiSeq 2000/2500" ~ "Forward",
machine == "HiSeq 3000/4000" ~ "Reverse",
machine == "MiniSeq" ~ "Reverse",
machine == "NovaSeq" ~ "Forward"
)
return(direction)
}
machineDirection("Forward")
machineDirection("NextSeq")
library(dplyr)
machineDirection("NextSeq")
runApp()
runApp()
runApp()
df
df[1:5, 1] = c(1,2,3,4,5)
df
runApp()
runApp()
runApp()
library(rhandsontable)
df3 <- tableConstructor()
rhandsontable(df3)
rhandsontable(df3[3:4, 3:4] == TRUE)
rhandsontable(df3[3:4, 3:4] = TRUE)
df3[1:4, 4] = c(TRUE, TRUE, TRUE, TRUE)
df3
which(df3==TRUE, useNames = TRUE)
which(df3==TRUE, arr.ind = TRUE, useNames = TRUE)
setA <- dualIndexTable('96N Set A', 'Forward')
setA
seqs <- sequencesToAdd(df3, setA)
seqs
indexDF = data.frame(index = rep("",50), stringsAsFactors = FALSE)
indexDF[1:4, 1] = seqs
indexDF
indexDF[(4+1):(4+4), 1] = indices
indexDF[(4+1):(4+4), 1] = seqs
indexDF
runApp()
runApp()
runApp()
indexDF
apply(indexDF, match, "")
apply(indexDF, match, x="")
match("", indexDF$1)
match("", indexDF[,1])
runApp()
runApp()
ind = "TCCTGAGC+ACTGCATA"
grep("^[ACTGactg]{6,8}+?[ACTGactg]{6,8}$", ind)
grep("^[ACTGactg]{6,8}\+?[ACTGactg]{6,8}$", ind)
grep("^[ACTGactg]{6,8}\\+?[ACTGactg]{6,8}$", ind)
grep("^[ACTGactg]{6,8}\\+?[ACTGactg]{0,8}$", ind)
ind2 = "TCCTGAGC+ACTjCATA"
grep("^[ACTGactg]{6,8}\\+?[ACTGactg]{0,8}$", ind2)
grepl("^[ACTGactg]{6,8}\\+?[ACTGactg]{0,8}$", ind)
grepl("^[ACTGactg]{6,8}\\+?[ACTGactg]{0,8}$", ind2)
runApp()
