abline(h = 1-(1-0.5)^(1/m), lty=4, col=4) # Sidek
var.test(golub[1, ] ~ gol.fac)
gol.fac = factor(golub.cl, levels = 0:1, labels = c("ALL", "AML"))
table(gol.fac)
library(genetics)
library(coin)
path <- "http://www.biostat.umn.edu/~cavanr/FMS_data.txt"
fms <- read.delim(path, header = TRUE, sep = "\t")
trait <- as.numeric(fms$pre.BMI > 25)
pvals <- numeric(225)
for (i in 1:225) {
mysnp <- ordered(fms[, i + 1])
pvals[i] <- pvalue(independence_test(trait ~ mysnp)) }
# No p-value adjustment.
table(pvals < 0.05)
# Bonferroni.
table(pvals < 0.05 / 225)
# Sidek.
table(pvals < 1 - (1 - 0.05)^(1 / 225))
# Benjamini-Hochberg.
table(sort(pvals, na.last = TRUE) * 225 / (1:225) < 0.05)
table(sort(pvals) * 225 / (1:225) < 0.05)
knitr::opts_chunk$set(echo = TRUE)
library(genetics)
path = "http://www.biostat.umn.edu/~cavanr/FMS_data.txt"
fms = read.delim(path, header = TRUE, sep = "\t")
attach(fms)
lm.fit = lm(NDRM.CH ~ actn3_r577x + Gender)
summary(lm.fit)
fms
NDRM.CH
-23.472 + c(-1, 1) * qt(0.975, df = 599) * 2.565
confint(lm.fit)
lm.fit2 = lm(NDRM.CH ~ actn3_r577x + Gender + actn3_r577x:Gender)
anova(lm.fit, lm.fit2)
plot(fitted(lm.fit2), residuals(lm.fit2))
abline(h=0, lty=2)
qqnorm(residuals(lm.fit2))
qqline(residuals(lm.fit2))
library(multtest)
data(golub)
library(multtest)
data(golub)
knitr::opts_chunk$set(echo = TRUE)
gol.fac = factor(golub.cl, levels=0:1, labels=c("ALL", "AML"))
n1 = summary(gol.fac)[1] # ALL
n2 = summary(gol.fac)[2] # AML
n = n1 + n2
m = 10      # number of genes to test
X = golub[1:m, ] # original data
# Center the two samples
muALL = rowmeans(X[, gol.fac=="ALL"])
gol.fac = factor(golub.cl, levels=0:1, labels=c("ALL", "AML"))
n1 = summary(gol.fac)[1] # ALL
n2 = summary(gol.fac)[2] # AML
n = n1 + n2
m = 10      # number of genes to test
X = golub[1:m, ] # original data
# Center the two samples
muALL = rowMeans(X[, gol.fac=="ALL"])
muAML = rowMeans(X[, gol.fac=="AML"])
Y <- X
Y[, gol.fac=="ALL"] <- Y[, gol.fac=="ALL"] - matrix(muALL, m, n1, byrow=FALSE)
Y[, gol.fac=="AML"] <- Y[, gol.fac=="AML"] - matrix(muAML, m, n2, byrow=FALSE)
B = 250    # number of bootstrap samples
F.mat = matrix(nrow=B, ncol=m) # initialise matrix of bootstrapped statistics
for (b in 1:B) {
indices = sample(1:n, n, replace=TRUE) # indices for the bootstrapped samples
f.test.fun = function(x) {
var.test(x ~gol.fac, conf.level=0.95)$statistic
}
F.mat[b, ] = apply(Y[indices], 1, f.test.fun)
}
gol.fac = factor(golub.cl, levels=0:1, labels=c("ALL", "AML"))
n1 = summary(gol.fac)[1] # ALL
n2 = summary(gol.fac)[2] # AML
n = n1 + n2
m = 10      # number of genes to test
X = golub[1:m, ] # original data
# Center the two samples
muALL = rowMeans(X[, gol.fac=="ALL"])
muAML = rowMeans(X[, gol.fac=="AML"])
Y <- X
Y[, gol.fac=="ALL"] <- Y[, gol.fac=="ALL"] - matrix(muALL, m, n1, byrow=FALSE)
Y[, gol.fac=="AML"] <- Y[, gol.fac=="AML"] - matrix(muAML, m, n2, byrow=FALSE)
B = 250    # number of bootstrap samples
F.mat = matrix(nrow=B, ncol=m) # initialise matrix of bootstrapped statistics
for (b in 1:B) {
indices = sample(1:n, n, replace = TRUE)
f.test.fun = function(x) {
var.test(x ~ gol.fac, conf.level = 0.95)$statistic
}
F.mat[b, ] = apply(Y[, indices], 1, f.test.fun)
}
F.mat
D = data.frame(F.mat)[,1:5]
colnames(D) = golub.gnames[1:5,3]
plot(log(D))
library(MASS)
f.hat = kde2d(log(F.mat[, 4]), log(F.mat[, 5]))
persp(f.hat, theta = 40, phi = 25, shade = 0.5, ticktype = "detailed",
xlab = golub.gnames[1, 3],
ylab = golub.gnames[2, 3],
zlab = "density estimate")
contour(f.hat, xlab = golub.gnames[1,3], ylab = golub.gnames[2,3])
c = 0.5 # initial value
alpha = 0.025 # target FWER
alpha.c = 1 # initial value for the estimated FWER
while (alpha.c > alpha) {
c =c+0.001
rs = rowSums(F.mat > c) # for each sample, count how many reject H0 alpha.c = mean(rs >= 1)
}
c
c = 0.5 # initial value
alpha = 0.025 # target FWER
alpha.c = 1 # initial value for the estimated FWER
while (alpha.c > alpha) {
c =c+0.001
rs = rowSums(F.mat > c) # for each sample, count how many reject H0
alpha.c = mean(rs >= 1)
}
c # the determined critical value
c=1
alpha = 0.025
alpha.c = 1
while (alpha.c > alpha) {
c =c-0.001
ls = rowSums(F.mat < c) # for each sample, count how many reject H0
alpha.c = mean(ls >= 1)
}
c # the determined critical value
?confint
confint(lm.fit2)
library(genetics)
path = "http://www.biostat.umn.edu/~cavanr/FMS_data.txt"
fms = read.delim(path, header = TRUE, sep = "\t")
attach(fms)
lm.fit = lm(NDRM.CH ~ actn3_r577x + Gender)
summary(lm.fit)
-23.472 + c(-1, 1) * qt(0.975, df = 599) * 2.565
confint(lm.fit)
plot(fitted(lm.fit2), residuals(lm.fit2))
gol.fac = factor(golub.cl, levels=0:1, labels=c("ALL", "AML"))
n1 = summary(gol.fac)[1] # ALL
n2 = summary(gol.fac)[2] # AML
n = n1 + n2
m = 10      # number of genes to test
X = golub[1:m, ] # original data
# Center the two samples
muALL = rowMeans(X[, gol.fac=="ALL"])
muAML = rowMeans(X[, gol.fac=="AML"])
Y <- X
Y[, gol.fac=="ALL"] <- Y[, gol.fac=="ALL"] - matrix(muALL, m, n1, byrow=FALSE)
Y[, gol.fac=="AML"] <- Y[, gol.fac=="AML"] - matrix(muAML, m, n2, byrow=FALSE)
B = 250    # number of bootstrap samples
F.mat = matrix(nrow=B, ncol=m) # initialise matrix of bootstrapped statistics
for (b in 1:B) {
indices = sample(1:n, n, replace = TRUE)
f.test.fun = function(x) {
var.test(x ~ gol.fac, conf.level = 0.95)$statistic
}
F.mat[b, ] = apply(Y[, indices], 1, f.test.fun)
}
D = data.frame(F.mat)[,1:5]
colnames(D) = golub.gnames[1:5,3]
plot(log(D))
library(MASS)
f.hat = kde2d(log(F.mat[, 4]), log(F.mat[, 5]))
persp(f.hat, theta = 40, phi = 25, shade = 0.5, ticktype = "detailed",
xlab = golub.gnames[1, 3],
ylab = golub.gnames[2, 3],
zlab = "density estimate")
contour(f.hat, xlab = golub.gnames[1,3], ylab = golub.gnames[2,3])
c = 0.5 # initial value
alpha = 0.025 # target FWER
alpha.c = 1 # initial value for the estimated FWER
while (alpha.c > alpha) {
c =c+0.001
rs = rowSums(F.mat > c) # for each sample, count how many reject H0
alpha.c = mean(rs >= 1)
}
c # the determined critical value
c=1
alpha = 0.025
alpha.c = 1
while (alpha.c > alpha) {
c =c-0.001
ls = rowSums(F.mat < c) # for each sample, count how many reject H0
alpha.c = mean(ls >= 1)
}
c # the determined critical value
confint(lm.fit2)
confint(lm.fit)
lm.fit2 = lm(NDRM.CH ~ actn3_r577x + Gender + actn3_r577x:Gender)
anova(lm.fit, lm.fit2)
lm.fit2 = lm(NDRM.CH ~ actn3_r577x + Gender + actn3_r577x:Gender)
anova(lm.fit, lm.fit2)
plot(fitted(lm.fit2), residuals(lm.fit2))
abline(h=0, lty=2)
qqnorm(residuals(lm.fit2))
qqline(residuals(lm.fit2))
confint(lm.fit2)
confint(lm.fit)
genoDosage <- as.numeric(actn3_r577x) - 1
lm.fit  = lm(NDRM.CH ~ genoDosage + Gender)
lm.fit2 = lm(NDRM.CH ~ genoDosage + Gender + genoDosage:Gender)
summary(lm.fit)
confint(lm.fit)
plot(fitted(lm.fit2), residuals(lm.fit2))
abline(h = 0, lty = 2)
qqnorm(residuals(lm.fit2))
qqline(residuals(lm.fit2))
Fstat <- apply(X, 1, f.test.fun) sort(Fstat)
Fstat <- apply(X, 1, f.test.fun)
sort(Fstat)
knitr::opts_chunk$set(echo = TRUE)
genotypes1 <- read.table("./data/genotypes1.csv", sep=",")
genotypes1
# Study 1
genotypes1 <- read.table("./data/genotypes1.csv", sep=",")
phenotypes1 <- read.table("./data/phenotypes1.csv", sep=",")
# Study 1
genotypes1 <- read.table("./data/genotypes1.csv", sep=",")
phenotypes1 <- read.table("./data/phenotype1.csv", sep=",")
# Study 2
genotypes2 <- read.table("./data/genotypes2.csv", sep=",")
phenotypes2 <- read.table("./data/phenotype2.csv", sep=",")
# Study 3
genotypes3 <- read.table("./data/genotypes3.csv", sep=",")
class(snp10001)
length(snp10001)
library(SNPassoc)
data(SNPs)
dim(SNPs)
colnames(SNPs)
snp10001 <- SNPs$snp10001
is.numeric(snp10001)
levels(snp10001)
class(snp10001)
length(snp10001)
freq <- table(snp10001)
plot(freq)
## 2 - Functions & Loops
# contigency table construction
X <- table(SNPs$casco, SNPs$snp10001)
X
# H0 = 2 variables independent
# H1 = 2 variables dependent
myChisq <- function(Z) {
n <- sum(Z)       # sample size
out <- 0          # initialize the output
for (r in 1:2) {  # loop across rows and cols
for (c in 1:3) {
o <- Z[r, c]                        # observed
e <- sum(Z[r, ]) * sum(Z[, c]) / n  # expected
out <- out + (o - e)^2 / e          # collect the values
}
}
return(out) }
myChisq(X)
qchisq(0.95, df = 2)
chisq.test(X)
## 3 - Exploratory data analysis on microarrays
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.10")
shiny::runApp('Work/Shiny_Apps/indexChecker')
tableConstructor <- function() {
rows = c("A", "B", "C", "D", "E", "F", "G", "H")
plate = data.frame(matrix(ncol=16, nrow=8), row.names=rows)
colnames(plate) <- seq(1, 16)
plate[is.na(plate)] = FALSE
return(plate)
}
tableConstructor()
runApp('Work/Shiny_Apps/indexChecker')
runApp('Work/Shiny_Apps/indexChecker')
runApp('Work/Shiny_Apps/indexChecker')
runApp('Work/Shiny_Apps/indexChecker')
runApp('Work/Shiny_Apps/indexChecker')
shiny::runApp('Work/Shiny_Apps/indexChecker')
runApp('Work/Shiny_Apps/indexChecker')
runApp('~/Dropbox/Work/R apps')
runApp('Work/Shiny_Apps/indexChecker')
tableConstructor()
runApp('Work/Shiny_Apps/indexChecker')
tableConstructor <- function(rows=8, cols=12) {
rows = c("A", "B", "C", "D", "E", "F", "G", "H")
plate = data.frame(matrix(ncol=cols, nrow=rows), row.names=rows)
colnames(plate) <- seq(1, cols)
plate[is.na(plate)] = FALSE
return(plate)
}
plate
tableConstructor()
tableConstructor <- function(rows=8, columns=12) {
rows = c("A", "B", "C", "D", "E", "F", "G", "H")
plate = data.frame(matrix(ncol=columns, nrow=rows), row.names=rows)
colnames(plate) <- seq(1, cols)
plate[is.na(plate)] = FALSE
return(plate)
}
tableConstructor()
tableConstructor <- function(rows=8, columns=12) {
rows = c("A", "B", "C", "D", "E", "F", "G", "H")
plate = data.frame(matrix(ncol=12, nrow=8), row.names=rows)
colnames(plate) <- seq(1, cols)
plate[is.na(plate)] = FALSE
return(plate)
}
tableConstructor()
tableConstructor <- function(rows=8, columns=12) {
rows = c("A", "B", "C", "D", "E", "F", "G", "H")
plate = data.frame(matrix(ncol=columns, nrow=rows), row.names=rows)
colnames(plate) <- seq(1, columns)
plate[is.na(plate)] = FALSE
return(plate)
}
tableConstructor()
tableConstructor <- function(rows=8, cols=12) {
rows = c("A", "B", "C", "D", "E", "F", "G", "H")
plate = data.frame(matrix(ncol=cols, nrow=rows), row.names=rows)
colnames(plate) <- seq(1, cols)
plate[is.na(plate)] = FALSE
return(plate)
}
tableConstructor()
tableConstructor <- function(rows=8, cols=12) {
rows = c("A", "B", "C", "D", "E", "F", "G", "H")
plate = data.frame(matrix(ncol=12, nrow=8), row.names=rows)
colnames(plate) <- seq(1, 12)
plate[is.na(plate)] = FALSE
return(plate)
}
tableConstructor()
hammingDistance <- function(string1, string2) {
# Calculate the hamming distance between 2 strings
minLength = min(nchar(string1), nchar(string2))
# split strings into parsable characters
split1 <- strsplit(string1, "")[[1]]
split2 <- strsplit(string2, "")[[1]]
distance = sum(!split1[1:minLength] == split2[1:minLength])
return(distance)
}
checkIndex <- function(indexTable) {
# Compare differences between all indices in a table
outputDF = data.frame(index1=integer(),
index2=integer(),
sequence1=character(),
sequence2=character(),
distance=integer(),
stringsAsFactors=FALSE)
numIndices = nrow(indexTable)
# loop over all indices
for (i in 1:numIndices-1) {
index1 = trimws(indexTable[i,1])
# ignore blank entry
if (nchar(index1) == 0 ) next
for (j in i+1:numIndices) {
index2 = trimws(indexTable[j,1])
# ignore blank entry
if (nchar(index2) == 0 ) next
distance = hammingDistance(index1, index2)
if (distance < 3) {
collision <- c(index1=i, index2=j, sequence1=index1, sequence2=index2, distance=distance)
outputDF[nrow(outputDF) + 1, ] = collision
}
}
}
return(outputDF)
}
inputDF <- data.frame(index=c("aattccgg", "aattccgg"))
inputDF
checkIndex(inputDF)
checkIndex <- function(indexTable) {
# Compare differences between all indices in a table
outputDF = data.frame(index1=integer(),
index2=integer(),
sequence1=character(),
sequence2=character(),
distance=integer(),
stringsAsFactors=FALSE)
numIndices = nrow(indexTable)
# loop over all indices
for (i in 1:numIndices-1) {
index1 = trimws(indexTable[i,1])
# ignore blank entry
if (!nchar(index1)) next
for (j in i+1:numIndices) {
index2 = trimws(indexTable[j,1])
# ignore blank entry
if (!nchar(index2)) next
distance = hammingDistance(index1, index2)
if (distance < 3) {
collision <- c(index1=i, index2=j, sequence1=index1, sequence2=index2, distance=distance)
outputDF[nrow(outputDF) + 1, ] = collision
}
}
}
return(outputDF)
}
checkIndex(inputDF)
runApp('Work/Shiny_Apps/indexChecker')
runApp('Dropbox/Work/R apps')
runApp('Work/Shiny_Apps/indexChecker')
hammingDistance <- function(string1, string2) {
# Calculate the hamming distance between 2 strings
minLength = min(nchar(string1), nchar(string2))
# split strings into parsable characters
split1 <- strsplit(string1, "")[[1]]
split2 <- strsplit(string2, "")[[1]]
distance = sum(!split1[1:minLength] == split2[1:minLength])
return(distance)
}
checkIndex <- function(indexTable) {
# Compare differences between all indices in a table
outputDF = data.frame(index1=integer(),
index2=integer(),
sequence1=character(),
sequence2=character(),
distance=integer(),
stringsAsFactors=FALSE)
numIndices = nrow(indexTable)
print(numIndices)
# loop over all indices
for (i in 1:numIndices-1) {
index1 = trimws(indexTable[i,1])
# ignore blank entry
if (nchar(index1) == 0 ) next
for (j in i+1:numIndices) {
index2 = trimws(indexTable[j,1])
# ignore blank entry
if (nchar(index2) == 0 ) next
distance = hammingDistance(index1, index2)
if (distance < 3) {
collision <- c(index1=i, index2=j, sequence1=index1, sequence2=index2, distance=distance)
outputDF[nrow(outputDF) + 1, ] = collision
}
}
}
return(outputDF)
}
testTable <- data.frame(index=c("aattccgg", "atcgatcg", "atcgatcc"))
checkIndex(testTable)
checkIndex <- function(indexTable) {
# Compare differences between all indices in a table
outputDF = data.frame(index1=integer(),
index2=integer(),
sequence1=character(),
sequence2=character(),
distance=integer(),
stringsAsFactors=FALSE)
numIndices = nrow(indexTable)
print(numIndices)
# loop over all indices
for (i in 1:numIndices-1) {
index1 = trimws(indexTable[i,1])
print(i)
# ignore blank entry
if (nchar(index1) == 0 ) next
for (j in i+1:numIndices) {
index2 = trimws(indexTable[j,1])
# ignore blank entry
if (nchar(index2) == 0 ) next
distance = hammingDistance(index1, index2)
if (distance < 3) {
collision <- c(index1=i, index2=j, sequence1=index1, sequence2=index2, distance=distance)
outputDF[nrow(outputDF) + 1, ] = collision
}
}
}
return(outputDF)
}
checkIndex(testTable)
1:3-1
checkIndex <- function(indexTable) {
# Compare differences between all indices in a table
outputDF = data.frame(index1=integer(),
index2=integer(),
sequence1=character(),
sequence2=character(),
distance=integer(),
stringsAsFactors=FALSE)
numIndices = nrow(indexTable)
print(numIndices)
# loop over all indices
for (i in 1:(numIndices-1)) {
index1 = trimws(indexTable[i,1])
print(i)
# ignore blank entry
if (nchar(index1) == 0 ) next
for (j in (i+1):numIndices) {
index2 = trimws(indexTable[j,1])
# ignore blank entry
if (nchar(index2) == 0 ) next
distance = hammingDistance(index1, index2)
if (distance < 3) {
collision <- c(index1=i, index2=j, sequence1=index1, sequence2=index2, distance=distance)
outputDF[nrow(outputDF) + 1, ] = collision
}
}
}
return(outputDF)
}
checkIndex(testTable)
runApp('Work/Shiny_Apps/indexChecker')
setwd("~/Work/Shiny_Apps")
runApp('indexChecker')
setwd("~/Work/Shiny_Apps/indexChecker")
runApp()
getwd()
shiny::runApp()
